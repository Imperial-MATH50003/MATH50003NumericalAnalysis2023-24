# Integers


In this section we discuss the following:

1. Binary representation: Any real number can be represented in binary, that is, by an infinite sequence of 0s and 1s (bits). We review  binary representation.
2. Unsigned integers:  We discuss how computers represent non-negative integers using only $p$-bits, via [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic).
3. Signed integers: we discuss how negative integers are handled using the [Two's-complement](https://en.wikipedia.org/wiki/Two's_complement) format.



Mathematically, CPUs only act on $p$-bits at a time, with $2^p$ possible sequences.
That is, essentially all functions $f$ are either of the form
$f : ℤ_{2^p} → ℤ_{2^p}$ or  $f : ℤ_{2^p} × ℤ_{2^p} → ℤ_{2^p}$,
where we use the following notation:

**Definition (signed integers)** Denote the
$$
ℤ_m := \{0 , 1 , …, m-1 \}
$$
∎

The limitations this imposes on representing integers is substantial. 
If we have an implementation of $+$, which we shall denote $⊕_m$, how can we possibly represent
$m + 1$ in this implementation when the result is above the largest possible integer?

The solution that is used is straightforward: the CPU uses modular arithmetic. E.g., we have
$$
(m-1) ⊕_m 1 = m\ ({\rm mod}\ m) = 0.
$$
In this chapter we discuss the implications of this approach and how it works with negative numbers.


We will write integers in binary format, that is, as sequence of `0`s and `1`s:

**Definition (binary format)**
For $B_0,\ldots,B_p \in \{0,1\}$ denote an integer in _binary format_ by:
$$
±(B_p\ldots B_1B_0)_2 := ±\sum_{k=0}^p B_k 2^k
$$
∎


**Example (integers in binary)**
A simple integer example is $5 = 2^2 + 2^0 = (101)_2$.
On the other hand, we write $-5 = -(101)_2$.
Another example is $258 = 2^8 + 2 = (1000000010)_2$.
∎


## Unsigned Integers


Computers represent integers by a finite number of $p$ bits,
with $2^p$ possible combinations of 0s and 1s. For _unsigned integers_ (non-negative integers) 
these bits dictate the first $p$ binary digits: $(B_{p-1}\ldots B_1B_0)_2$. 
 
Integers on a computer follow [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic):
Integers represented with $p$-bits on a computer actually 
represent elements of ${\mathbb Z}_{2^p}$ and integer arithmetic on a computer is 
equivalent to arithmetic modulo $2^p$. We denote modular arithmetic with $m = 2^p$ as follows:
$$
\begin{align*}
x ⊕_m y &:= (x+y) ({\rm mod}\ m) \\
x ⊖_m y &:= (x-y) ({\rm mod}\ m) \\
x ⊗_m y &:= (x*y) ({\rm mod}\ m)
\end{align*}
$$
When $m$ is implied by context we just write $⊕, ⊖, ⊗$.

**Example (arithmetic with  8-bit unsigned integers)** 
If  arithmetic lies between $0$ and $m = 2^8 = 256$ works as expected. 
For example,
$$
\begin{align*}
17 ⊕_{256} 3 = 20 ({\rm mod}\ 256) = 20 \\
17 ⊖_{256} 3 = 14 ({\rm mod}\ 256) = 14
\end{align*}
$$
∎

**Example (overflow with 8-bit unsigned integers)** If we go beyond the range
the result ``wraps around". For example, with integers we have
$$
255 + 1 = (11111111)_2 + (00000001)_2 = (100000000)_2 = 256
$$
However, the result is impossible to store in just 8-bits! 
So as mentioned instead it treats the integers as elements of ${\mathbb Z}_{256}$:
$$
255 ⊕_{256} 1 = 255 + 1 \ ({\rm mod}\ 256) = (00000000)_2 \ ({\rm mod}\ 256) = 0 \ ({\rm mod}\ 256)
$$
On the other hand, if we go below $0$ we wrap around from above:
$$
3 ⊖_{256} 5 = -2 ({\rm mod}\ 256) = 254 = (11111110)_2
$$
∎

**Example (multiplication of 8-bit unsigned integers)** 
Multiplication works similarly: for example,
$$
254 ⊗_{256} 2 = 254 * 2 \ ({\rm mod}\ 256) = 252 \ ({\rm mod}\ 256) = (11111100)_2 \ ({\rm mod}\ 256)
$$
∎

## Signed integer

Signed integers use the [Two's complemement](https://epubs.siam.org/doi/abs/10.1137/1.9780898718072.ch3)
convention. The convention is if the first bit is 1 then the number is negative: the number $2^p - y$
is interpreted as $-y$.
Thus for $p = 8$ we are interpreting
$2^7$ through $2^8-1$ as negative numbers. More precisely:

**Definition ($ℤ_{2^p}^s$, unsigned integers)**
$$
ℤ_{2^p}^s := \{-2^{p-1} ,…, -1 ,0,1, …, 2^{p-1}-1 \}
$$
∎

**Definition (Shifted mod)**
Define for $y = x\ ({\rm mod}\ 2^p)$
$$
x\ ({\rm mod}^{\rm s}\ 2^p) := \begin{cases} y & 0 ≤ y ≤ 2^{p-1}-1 \\
                             y - 2^p & 2^{p-1} ≤ y ≤ 2^p - 1
                             \end{cases}
$$
∎

Note that if $R_p(x) = x ({\rm mod}^{\rm s}\ 2^p)$ then it can be viewed as a map
$R_p : ℤ → ℤ_{2^p}^s$ or a one-to-one map
$R_p : ℤ_{2^p} → ℤ_{2^p}^s$ whose inverse is $R_p^{-1}(x) = x \mod 2^p$. 


Arithmetic works precisely
the same for signed and unsigned integers, e.g. we have
$$
x ⊕_{2^p}^s y := x + y ({\rm mod}^{\rm s}\ 2^p)
$$

**Example (addition of 8-bit integers)**
Consider `(-1) + 1` in 8-bit arithmetic. The number $-1$ has the same bits as
$2^8 - 1 = 255$. Thus this is equivalent to the previous question and we get the correct
result of `0`. In other words:
$$
-1 ⊕_{256} 1 = -1 + 1 \ ({\rm mod}\ 2^p) = 2^p-1  + 1 \ ({\rm mod}\ 2^p) = 2^p \ ({\rm mod}\ 2^p) = 0 \ ({\rm mod}\ 2^p)
$$
∎

**Example (multiplication of 8-bit integers)**
Consider `(-2) * 2`. $-2$ has the same bits as $2^{256} - 2 = 254$ and $-4$ has the
same bits as $2^{256}-4 = 252$, and hence from the previous example we get the correct result of `-4`.
In other words:
$$
(-2) ⊗_{2^p}^s 2 = (-2) * 2 \ ({\rm mod}^{\rm s}\ 2^p) = (2^p-2) * 2 \ ({\rm mod}^{\rm s}\ 2^p) = 2^{p+1}-4 \ ({\rm mod}^{\rm s}\ 2^p) = -4
$$
∎