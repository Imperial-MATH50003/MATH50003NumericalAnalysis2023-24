
\section{Integers}
In this section we discuss the following:

\begin{itemize}
\item[1. ] Binary representation: Any real number can be represented in binary, that is, by an infinite sequence of 0s and 1s (bits). We review  binary representation.


\item[2. ] Unsigned integers:  We discuss how computers represent non-negative integers using only $p$-bits, via \href{https://en.wikipedia.org/wiki/Modular_arithmetic}{modular arithmetic}.


\item[3. ] Signed integers: we discuss how negative integers are handled using the \href{https://en.wikipedia.org/wiki/Two's_complement}{Two's-complement} format.

\end{itemize}
Mathematically, CPUs only act on $p$-bits at a time, with $2^p$ possible sequences. That is, essentially all functions $f$ are either of the form $f : \ensuremath{\bbZ}_{2^p} \ensuremath{\rightarrow} \ensuremath{\bbZ}_{2^p}$ or  $f : \ensuremath{\bbZ}_{2^p} \ensuremath{\times} \ensuremath{\bbZ}_{2^p} \ensuremath{\rightarrow} \ensuremath{\bbZ}_{2^p}$, where we use the following notation:

\begin{definition}[signed integers] Denote the
\[
\ensuremath{\bbZ}_m := \{0 , 1 , \ensuremath{\ldots}, m-1 \}
\]
\end{definition}

The limitations this imposes on representing integers is substantial.  If we have an implementation of $+$, which we shall denote $\ensuremath{\oplus}_m$, how can we possibly represent $m + 1$ in this implementation when the result is above the largest possible integer?

The solution that is used is straightforward: the CPU uses modular arithmetic. E.g., we have
\[
(m-1) \ensuremath{\oplus}_m 1 = m\ ({\rm mod}\ m) = 0.
\]
In this chapter we discuss the implications of this approach and how it works with negative numbers.

We will write integers in binary format, that is, as sequence of \texttt{0}s and \texttt{1}s:

\begin{definition}[binary format] For $B_0,\ldots,B_p \in \{0,1\}$ denote an integer in \emph{binary format} by:
\[
\ensuremath{\pm}(B_p\ldots B_1B_0)_2 := \ensuremath{\pm}\sum_{k=0}^p B_k 2^k
\]
\end{definition}

\begin{example}[integers in binary] A simple integer example is $5 = 2^2 + 2^0 = (101)_2$. On the other hand, we write $-5 = -(101)_2$. Another example is $258 = 2^8 + 2 = (1000000010)_2$. \end{example}

\subsection{Unsigned Integers}
Computers represent integers by a finite number of $p$ bits, with $2^p$ possible combinations of 0s and 1s. For \emph{unsigned integers} (non-negative integers)  these bits dictate the first $p$ binary digits: $(B_{p-1}\ldots B_1B_0)_2$. 

Integers on a computer follow \href{https://en.wikipedia.org/wiki/Modular_arithmetic}{modular arithmetic}: Integers represented with $p$-bits on a computer actually  represent elements of ${\mathbb Z}_{2^p}$ and integer arithmetic on a computer is  equivalent to arithmetic modulo $2^p$. We denote modular arithmetic with $m = 2^p$ as follows:


\begin{align*}
x \ensuremath{\oplus}_m y &:= (x+y) ({\rm mod}\ m) \\
x \ensuremath{\ominus}_m y &:= (x-y) ({\rm mod}\ m) \\
x \ensuremath{\otimes}_m y &:= (x*y) ({\rm mod}\ m)
\end{align*}
When $m$ is implied by context we just write $\ensuremath{\oplus}, \ensuremath{\ominus}, \ensuremath{\otimes}$.

\begin{example}[arithmetic with  8-bit unsigned integers]  If  arithmetic lies between $0$ and $m = 2^8 = 256$ works as expected.  For example,


\begin{align*}
17 \ensuremath{\oplus}_{256} 3 = 20 ({\rm mod}\ 256) = 20 \\
17 \ensuremath{\ominus}_{256} 3 = 14 ({\rm mod}\ 256) = 14
\end{align*}
\end{example}

\begin{example}[overflow with 8-bit unsigned integers] If we go beyond the range the result ``wraps around". For example, with integers we have
\[
255 + 1 = (11111111)_2 + (00000001)_2 = (100000000)_2 = 256
\]
However, the result is impossible to store in just 8-bits!  So as mentioned instead it treats the integers as elements of ${\mathbb Z}_{256}$:
\[
255 \ensuremath{\oplus}_{256} 1 = 255 + 1 \ ({\rm mod}\ 256) = (00000000)_2 \ ({\rm mod}\ 256) = 0 \ ({\rm mod}\ 256)
\]
On the other hand, if we go below $0$ we wrap around from above:
\[
3 \ensuremath{\ominus}_{256} 5 = -2 ({\rm mod}\ 256) = 254 = (11111110)_2
\]
\end{example}

\begin{example}[multiplication of 8-bit unsigned integers]  Multiplication works similarly: for example,
\[
254 \ensuremath{\otimes}_{256} 2 = 254 * 2 \ ({\rm mod}\ 256) = 252 \ ({\rm mod}\ 256) = (11111100)_2 \ ({\rm mod}\ 256)
\]
\end{example}

\subsection{Signed integer}
Signed integers use the \href{https://epubs.siam.org/doi/abs/10.1137/1.9780898718072.ch3}{Two's complemement} convention. The convention is if the first bit is 1 then the number is negative: the number $2^p - y$ is interpreted as $-y$. Thus for $p = 8$ we are interpreting $2^7$ through $2^8-1$ as negative numbers. More precisely:

\textbf{Definition ($\ensuremath{\bbZ}_{2^p}^s$, unsigned integers)}
\[
\ensuremath{\bbZ}_{2^p}^s := \{-2^{p-1} ,\ensuremath{\ldots}, -1 ,0,1, \ensuremath{\ldots}, 2^{p-1}-1 \}
\]
\ensuremath{\QED}

\begin{definition}[Shifted mod] Define for $y = x\ ({\rm mod}\ 2^p)$
\[
x\ ({\rm mod}^{\rm s}\ 2^p) := \begin{cases} y & 0 \ensuremath{\leq} y \ensuremath{\leq} 2^{p-1}-1 \\
                             y - 2^p & 2^{p-1} \ensuremath{\leq} y \ensuremath{\leq} 2^p - 1
                             \end{cases}
\]
\end{definition}

Note that if $R_p(x) = x ({\rm mod}^{\rm s}\ 2^p)$ then it can be viewed as a map $R_p : \ensuremath{\bbZ} \ensuremath{\rightarrow} \ensuremath{\bbZ}_{2^p}^s$ or a one-to-one map $R_p : \ensuremath{\bbZ}_{2^p} \ensuremath{\rightarrow} \ensuremath{\bbZ}_{2^p}^s$ whose inverse is $R_p^{-1}(x) = x \mod 2^p$. 

Arithmetic works precisely the same for signed and unsigned integers, e.g. we have
\[
x \ensuremath{\oplus}_{2^p}^s y := x + y ({\rm mod}^{\rm s}\ 2^p)
\]
\begin{example}[addition of 8-bit integers] Consider \texttt{(-1) + 1} in 8-bit arithmetic. The number $-1$ has the same bits as $2^8 - 1 = 255$. Thus this is equivalent to the previous question and we get the correct result of \texttt{0}. In other words:
\[
-1 \ensuremath{\oplus}_{256} 1 = -1 + 1 \ ({\rm mod}\ 2^p) = 2^p-1  + 1 \ ({\rm mod}\ 2^p) = 2^p \ ({\rm mod}\ 2^p) = 0 \ ({\rm mod}\ 2^p)
\]
\end{example}

\begin{example}[multiplication of 8-bit integers] Consider \texttt{(-2) * 2}. $-2$ has the same bits as $2^{256} - 2 = 254$ and $-4$ has the same bits as $2^{256}-4 = 252$, and hence from the previous example we get the correct result of \texttt{-4}. In other words:
\[
(-2) \ensuremath{\otimes}_{2^p}^s 2 = (-2) * 2 \ ({\rm mod}^{\rm s}\ 2^p) = (2^p-2) * 2 \ ({\rm mod}^{\rm s}\ 2^p) = 2^{p+1}-4 \ ({\rm mod}^{\rm s}\ 2^p) = -4
\]
\end{example}



